{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */(x => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function (x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\n\n// config/polyfills-node.ts\nimport { setTimeout as nodeSetTimeout } from \"timers\";\nvar setTimeout = nodeSetTimeout;\n\n// src/node/SetupServerApi.ts\nimport chalk from \"chalk\";\nimport { invariant as invariant3 } from \"outvariant\";\nimport { BatchInterceptor, InterceptorReadyState } from \"@mswjs/interceptors\";\n\n// src/SetupApi.ts\nimport { invariant } from \"outvariant\";\nimport { Emitter } from \"strict-event-emitter\";\n\n// src/utils/internal/devUtils.ts\nimport { format } from \"outvariant\";\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message) {\n  for (var _len = arguments.length, positionals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    positionals[_key - 1] = arguments[_key];\n  }\n  const interpolatedMessage = format(message, ...positionals);\n  return \"\".concat(LIBRARY_PREFIX, \" \").concat(interpolatedMessage);\n}\nfunction warn(message) {\n  for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    positionals[_key2 - 1] = arguments[_key2];\n  }\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message) {\n  for (var _len3 = arguments.length, positionals = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    positionals[_key3 - 1] = arguments[_key3];\n  }\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function (event) {\n    for (var _len4 = arguments.length, data2 = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      data2[_key4 - 1] = arguments[_key4];\n    }\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor() {\n    for (var _len5 = arguments.length, initialHandlers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      initialHandlers[_key5] = arguments[_key5];\n    }\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new Emitter();\n    this.publicEmitter = new Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers() {\n    for (var _len6 = arguments.length, handlers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      handlers[_key6] = arguments[_key6];\n    }\n    for (const handler of handlers) {\n      invariant(!Array.isArray(handler), devUtils.formatMessage('Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'), this.constructor.name);\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use() {\n    this.currentHandlers.unshift(...arguments);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach(handler => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers() {\n    for (var _len7 = arguments.length, nextHandlers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      nextHandlers[_key7] = arguments[_key7];\n    }\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    var _this = this;\n    return {\n      on: function () {\n        return _this.publicEmitter.on(...arguments);\n      },\n      removeListener: function () {\n        return _this.publicEmitter.removeListener(...arguments);\n      },\n      removeAllListeners: function () {\n        return _this.publicEmitter.removeAllListeners(...arguments);\n      }\n    };\n  }\n};\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, _ref) => {\n    let [key, rightValue] = _ref;\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/utils/request/MockedRequest.ts\nimport * as cookieUtils2 from \"cookie\";\nimport { store } from \"@mswjs/cookies\";\nimport { IsomorphicRequest } from \"@mswjs/interceptors\";\nimport { decodeBuffer } from \"@mswjs/interceptors/lib/utils/bufferUtils.js\";\nimport { Headers } from \"headers-polyfill\";\n\n// src/utils/request/getRequestCookies.ts\nimport * as cookieUtils from \"cookie\";\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\":\n      {\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n    case \"include\":\n      {\n        return getAllCookies();\n      }\n    default:\n      {\n        return {};\n      }\n  }\n}\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\nimport { stringToHeaders } from \"headers-polyfill\";\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = stringToHeaders(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest] = chunk.trim().split(\"=\");\n    acc[name2] = rest.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith(\"boundary=\")).map(s => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(\"--+\".concat(boundary));\n  const fields = data2.split(boundaryRegExp).filter(chunk => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map(chunk => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest.join(\"\\r\\n\\r\\n\");\n      const {\n        contentType: contentType2,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n        type: contentType2\n      });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends IsomorphicRequest {\n  constructor(url) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = decodeBuffer(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookieUtils2.parse(requestCookiesString) : {};\n    store.hydrate();\n    const cookiesFromStore = Array.from((_a = store.get({\n      ...this,\n      url: this.url.href\n    })) == null ? void 0 : _a.entries()).reduce((cookies, _ref2) => {\n      let [name, {\n        value\n      }] = _ref2;\n      return Object.assign(cookies, {\n        [name.trim()]: value\n      });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore\n    };\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", \"\".concat(name, \"=\").concat(value));\n    }\n    return {\n      ...forwardedCookies,\n      ...ownCookies\n    };\n  }\n};\n\n// src/utils/handleRequest.ts\nimport { until } from \"@open-draft/until\";\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter(handler => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\nimport getStringMatchScore from \"js-levenshtein\";\n\n// src/utils/internal/parseGraphQLRequest.ts\nimport { parse as parse3 } from \"graphql\";\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = request => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, \"\".concat(request.url.protocol, \"//\").concat(request.url.host)).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find(def => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = parse3(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(\"Given files do not have a key '\".concat(key, \"' .\"));\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(\"Property '\".concat(paths, \"' is not in operations.\"));\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\":\n      {\n        const query = request.url.searchParams.get(\"query\");\n        const variables = request.url.searchParams.get(\"variables\") || \"\";\n        return {\n          query,\n          variables: jsonParse(variables)\n        };\n      }\n    case \"POST\":\n      {\n        if ((_a = request.body) == null ? void 0 : _a.query) {\n          const {\n            query,\n            variables\n          } = request.body;\n          return {\n            query,\n            variables\n          };\n        }\n        if ((_b = request.body) == null ? void 0 : _b.operations) {\n          const {\n            operations,\n            map,\n            ...files\n          } = request.body;\n          const parsedOperations = jsonParse(operations) || {};\n          if (!parsedOperations.query) {\n            return null;\n          }\n          const parsedMap = jsonParse(map || \"\") || {};\n          const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n          return {\n            query: parsedOperations.query,\n            variables\n          };\n        }\n      }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const {\n    query,\n    variables\n  } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json\nvar codes_default = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"103\": \"Early Hints\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a Teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Too Early\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return res => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\nimport { objectToHeaders } from \"headers-polyfill\";\nfunction set() {\n  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    args[_key8] = arguments[_key8];\n  }\n  return res => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = objectToHeaders(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\nimport * as cookieUtils3 from \"cookie\";\nvar cookie = (name, value, options) => {\n  return res => {\n    const serializedCookie = cookieUtils3.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = value => {\n  return res => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/context/json.ts\nvar json = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      data: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      extensions: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\nimport { isNodeProcess } from \"is-node-process\";\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);\n};\nvar delay = durationOrMode => {\n  return res => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\":\n          {\n            delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n            break;\n          }\n        case \"real\":\n          {\n            delayTime = getRandomServerResponseTime();\n            break;\n          }\n        default:\n          {\n            throw new Error(\"Failed to delay a response: unknown delay mode \\\"\".concat(durationOrMode, \"\\\". Please make sure you provide one of the supported modes (\\\"real\\\", \\\"infinite\\\") or a number to \\\"ctx.delay\\\".\"));\n          }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\"Failed to delay a response: provided delay duration (\".concat(durationOrMode, \") exceeds the maximum allowed duration for \\\"setTimeout\\\" (\").concat(SET_TIMEOUT_MAX_ALLOWED_INT, \"). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \\\"infinite\\\" delay mode to delay the response indefinitely.\"));\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = errorsList => {\n  return res => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      errors: errorsList\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\nimport { isNodeProcess as isNodeProcess2 } from \"is-node-process\";\nimport { Headers as Headers2 } from \"headers-polyfill\";\nvar useFetch = isNodeProcess2() ? (input, init) => Promise.resolve().then(() => __toESM(__require(\"node-fetch\"))).then(_ref3 => {\n  let {\n    default: nodeFetch\n  } = _ref3;\n  return nodeFetch(input, init);\n}) : globalThis.fetch;\nvar augmentRequestInit = requestInit => {\n  const headers = new Headers2(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return {\n    ...requestInit,\n    headers: headers.all()\n  };\n};\nvar createFetchRequestParameters = input => {\n  const {\n    body: body2,\n    method\n  } = input;\n  const requestParameters = {\n    ...input,\n    body: void 0\n  };\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = function (input) {\n  let requestInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all()\n  };\n}\n\n// src/utils/logging/prepareResponse.ts\nimport { objectToHeaders as objectToHeaders2 } from \"headers-polyfill\";\nfunction prepareResponse(res) {\n  const responseHeaders = objectToHeaders2(res.headers);\n  const parsedBody = parseBody(res.body, responseHeaders);\n  return {\n    ...res,\n    body: parsedBody\n  };\n}\n\n// src/utils/matching/matchRequestUrl.ts\nimport { match } from \"path-to-regexp\";\nimport { getCleanUrl } from \"@mswjs/interceptors/lib/utils/getCleanUrl.js\";\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(\"/\".concat(path), \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, (_, parameterName, wildcard) => {\n    const expression = \"(.*)\";\n    if (!parameterName) {\n      return expression;\n    }\n    return parameterName.startsWith(\":\") ? \"\".concat(parameterName).concat(wildcard) : \"\".concat(parameterName).concat(expression);\n  }).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = getCleanUrl(url);\n  const result = match(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\nimport { Headers as Headers4 } from \"headers-polyfill\";\n\n// src/response.ts\nimport { Headers as Headers3 } from \"headers-polyfill\";\n\n// src/utils/internal/compose.ts\nfunction compose() {\n  for (var _len9 = arguments.length, fns = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    fns[_key9] = arguments[_key9];\n  }\n  return function () {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, arguments.length <= 0 ? undefined : arguments[0]);\n  };\n}\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides) {\n  let defaultTransformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultResponseTransformers;\n  return async function () {\n    const initialResponse = Object.assign({}, defaultResponse, {\n      headers: new Headers3({\n        \"x-powered-by\": \"msw\"\n      })\n    }, responseOverrides);\n    for (var _len10 = arguments.length, transformers = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      transformers[_key10] = arguments[_key10];\n    }\n    const resolvedTransformers = [...defaultTransformers, ...transformers].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find(frame => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = {\n      ...options.info,\n      callFrame\n    };\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped() {\n    let shouldSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(request, parsedResult, resolutionContext);\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(publicRequest, response, this.ctx);\n    return this.createExecutionResult(parsedResult, publicRequest, mockedResponse);\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx));\n      if (isIterable(result)) {\n        const {\n          value,\n          done\n        } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar restContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml\n};\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: \"\".concat(method, \" \").concat(path),\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const {\n      method,\n      path\n    } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(\"Found a redundant usage of query parameters in the request handler URL for \\\"\".concat(method, \" \").concat(path, \"\\\". Please match against a path instead and access query parameters in the response resolver function using \\\"req.url.searchParams\\\".\"));\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(request.url, this.info.path, resolutionContext == null ? void 0 : resolutionContext.baseUrl);\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s %s (%c%s%c)\"), getTimestamp(), request.method, publicUrl, \"color:\".concat(statusColor), \"\".concat(response2.status, \" \").concat(response2.statusText), \"color:inherit\");\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\nimport { invariant as invariant2 } from \"outvariant\";\nvar field = (fieldName, fieldValue) => {\n  return res => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      [fieldName]: fieldValue\n    });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  invariant2(fieldName.trim() !== \"\", devUtils.formatMessage(\"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"));\n  invariant2(fieldName !== \"data\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?', fieldName));\n  invariant2(fieldName !== \"errors\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?', fieldName));\n  invariant2(fieldName !== \"extensions\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?', fieldName));\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n};\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables, operationName) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.variables = variables;\n    this.operationName = operationName;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\"Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \\\"\".concat(operationType, \"\\\", but got \\\"\").concat(parsedNode.operationType, \"\\\").\"));\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(\"Failed to create a GraphQL handler: provided a DocumentNode with no operation name.\");\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? \"\".concat(operationType, \" (origin: \").concat(endpoint.toString(), \")\") : \"\".concat(operationType, \" \").concat(resolvedOperationName, \" (origin: \").concat(endpoint.toString(), \")\");\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(() => parseGraphQLRequest(request), error2 => console.error(error2.message));\n  }\n  getPublicRequest(request, parsedResult) {\n    var _a, _b;\n    return new GraphQLRequest(request, (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {}, (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : \"\");\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(\"Failed to intercept a GraphQL request at \\\"\".concat(request.method, \" \").concat(publicUrl, \"\\\": anonymous GraphQL operations are not supported.\\n\\nConsider naming this operation or using \\\"graphql.operation()\\\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      \"));\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? \"\".concat(parsedRequest == null ? void 0 : parsedRequest.operationType, \" \").concat(parsedRequest == null ? void 0 : parsedRequest.operationName) : \"anonymous \".concat(parsedRequest == null ? void 0 : parsedRequest.operationType);\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s (%c%s%c)\"), getTimestamp(), \"\".concat(requestInfo), \"color:\".concat(statusColor), \"\".concat(response2.status, \" \").concat(response2.statusText), \"color:inherit\");\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = getStringMatchScore(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = getStringMatchScore(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort((_ref4, _ref5) => {\n    let [leftScore] = _ref4;\n    let [rightScore] = _ref5;\n    return leftScore - rightScore;\n  }).filter(_ref6 => {\n    let [score] = _ref6;\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(_ref7 => {\n    let [, handler] = _ref7;\n    return handler;\n  });\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return \"Did you mean to request one of the following resources instead?\\n\\n\".concat(handlers.map(handler => \"  \\u2022 \".concat(handler.info.header)).join(\"\\n\"));\n  }\n  return \"Did you mean to request \\\"\".concat(handlers[0].info.header, \"\\\" instead?\");\n}\nfunction onUnhandledRequest(request, handlers) {\n  let strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"warn\";\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? \"\".concat(parsedGraphQLQuery.operationType, \" \").concat(parsedGraphQLQuery.operationName, \" (\").concat(request.method, \" \").concat(publicUrl, \")\") : \"\".concat(request.method, \" \").concat(publicUrl);\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [\"captured a request without a matching request handler:\", \"  \\u2022 \".concat(requestHeader), handlerSuggestion, \"If you still wish to intercept this unhandled request, please create a request handler for it.\\nRead more: https://mswjs.io/docs/getting-started/mocks\"].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", message);\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", message);\n          break;\n        }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\nimport { store as store2 } from \"@mswjs/cookies\";\nfunction readResponseCookies(request, response2) {\n  store2.add({\n    ...request,\n    url: request.url.toString()\n  }, response2);\n  store2.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(request, handlers, handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext);\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const {\n    handler,\n    response: response2\n  } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(\"Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\n\\n  \\u2022 %s\\n    %s\", response2, handler.info.header, handler.info.callFrame);\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/node/SetupServerApi.ts\nvar {\n  bold\n} = chalk;\nvar DEFAULT_LISTEN_OPTIONS = {\n  onUnhandledRequest: \"warn\"\n};\nvar SetupServerApi = class extends SetupApi {\n  constructor(interceptors) {\n    for (var _len11 = arguments.length, handlers = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n      handlers[_key11 - 1] = arguments[_key11];\n    }\n    super(...handlers);\n    this.interceptor = new BatchInterceptor({\n      name: \"setup-server\",\n      interceptors: interceptors.map(Interceptor2 => new Interceptor2())\n    });\n    this.resolvedOptions = {};\n    this.init();\n  }\n  init() {\n    this.interceptor.on(\"request\", async request => {\n      const mockedRequest = new MockedRequest(request.url, {\n        ...request,\n        body: await request.arrayBuffer()\n      });\n      const response2 = await handleRequest(mockedRequest, this.currentHandlers, this.resolvedOptions, this.emitter, {\n        transformResponse(response3) {\n          return {\n            status: response3.status,\n            statusText: response3.statusText,\n            headers: response3.headers.all(),\n            body: response3.body,\n            delay: response3.delay\n          };\n        }\n      });\n      if (response2) {\n        if (response2.delay) {\n          await new Promise(resolve => {\n            setTimeout(resolve, response2.delay);\n          });\n        }\n        request.respondWith(response2);\n      }\n      return;\n    });\n    this.interceptor.on(\"response\", (request, response2) => {\n      if (!request.id) {\n        return;\n      }\n      if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n        this.emitter.emit(\"response:mocked\", response2, request.id);\n      } else {\n        this.emitter.emit(\"response:bypass\", response2, request.id);\n      }\n    });\n  }\n  listen() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.resolvedOptions = mergeRight(DEFAULT_LISTEN_OPTIONS, options);\n    this.interceptor.apply();\n    invariant3([InterceptorReadyState.APPLYING, InterceptorReadyState.APPLIED].includes(this.interceptor.readyState), devUtils.formatMessage('Failed to start \"setupServer\": the interceptor failed to apply. This is likely an issue with the library and you should report it at \"%s\".'), \"https://github.com/mswjs/msw/issues/new/choose\");\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach(handler => {\n      const {\n        header,\n        callFrame\n      } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.log(\"\".concat(bold(\"\".concat(pragma, \" \").concat(header)), \"\\n  Declaration: \").concat(callFrame, \"\\n\"));\n    });\n  }\n  close() {\n    super.dispose();\n    this.interceptor.dispose();\n  }\n};\n\n// src/node/setupServer.ts\nimport { ClientRequestInterceptor } from \"@mswjs/interceptors/lib/interceptors/ClientRequest/index.js\";\nimport { XMLHttpRequestInterceptor } from \"@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js\";\nimport { FetchInterceptor } from \"@mswjs/interceptors/lib/interceptors/fetch/index.js\";\nvar setupServer = function () {\n  for (var _len12 = arguments.length, handlers = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    handlers[_key12] = arguments[_key12];\n  }\n  return new SetupServerApi([ClientRequestInterceptor, XMLHttpRequestInterceptor, FetchInterceptor], ...handlers);\n};\nexport { SetupServerApi, setupServer };","map":{"version":3,"names":["setTimeout","nodeSetTimeout","chalk","invariant","invariant3","BatchInterceptor","InterceptorReadyState","Emitter","format","LIBRARY_PREFIX","formatMessage","message","_len","arguments","length","positionals","Array","_key","interpolatedMessage","concat","warn","_len2","_key2","console","error","_len3","_key3","devUtils","pipeEvents","source","destination","rawEmit","emit","_isPiped","event","_len4","data2","_key4","call","toReadonlyArray","clone","Object","freeze","SetupApi","constructor","_len5","initialHandlers","_key5","validateHandlers","currentHandlers","emitter","publicEmitter","events","createLifeCycleEvents","_len6","handlers","_key6","handler","isArray","name","dispose","removeAllListeners","use","unshift","restoreHandlers","forEach","markAsSkipped","resetHandlers","_len7","nextHandlers","_key7","listHandlers","_this","on","removeListener","isObject","value","mergeRight","left","right","entries","reduce","result","_ref","key","rightValue","leftValue","assign","cookieUtils2","store","IsomorphicRequest","decodeBuffer","Headers","cookieUtils","getAllCookies","parse","document","cookie","getRequestCookies","request","location","credentials","origin","url","jsonParse","JSON","error2","stringToHeaders","parseContentHeaders","headersString","_a","_b","headers","contentType","get","disposition","Error","directives","split","acc","chunk","name2","rest","trim","join","slice","filename","parseMultipartData","boundary","filter","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","parsedBody","field2","contentHeaders","contentBody","contentType2","File","type","parsedValue","parseBody","body2","toLowerCase","hasMultipartContent","toString","hasJsonContent","includes","isStringEqual","actual","expected","MockedRequest","init","undefined","id","cache","integrity","keepalive","mode","priority","redirect","referrer","referrerPolicy","cookies","getCookies","body","text2","method","passthrough","status","statusText","once","requestCookiesString","ownCookies","hydrate","cookiesFromStore","from","href","_ref2","cookiesFromDocument","forwardedCookies","append","until","getResponse","resolutionContext","relevantHandlers","test","response","executionResult","previousResults","result2","run","shouldSkip","parsedResult","Promise","resolve","publicRequest","parsedRequest","getStringMatchScore","parse3","getPublicUrlFromRequest","pathname","URL","protocol","host","parseDocumentNode","node","operationDef","definitions","find","def","kind","operationType","operation","operationName","parseQuery","query","ast","extractMultipartVariables","variables","files","operations","pathArray","dotPath","lastPath","reversedPaths","reverse","paths","target","path","getGraphQLInput","searchParams","parsedOperations","parsedMap","parseGraphQLRequest","input","requestPublicUrl","statusCode","res","codes_default","String","objectToHeaders","set","_len8","args","_key8","value2","cookieUtils3","options","serializedCookie","serialize","json","stringify","data","payload","prevBody","nextBody","extensions","isNodeProcess","SET_TIMEOUT_MAX_ALLOWED_INT","MIN_SERVER_RESPONSE_TIME","MAX_SERVER_RESPONSE_TIME","NODE_SERVER_RESPONSE_TIME","getRandomServerResponseTime","Math","floor","random","delay","durationOrMode","delayTime","errors","errorsList","isNodeProcess2","Headers2","useFetch","then","__toESM","__require","_ref3","default","nodeFetch","globalThis","fetch","augmentRequestInit","requestInit","all","createFetchRequestParameters","requestParameters","derivedRequestInit","text","xml","getStatusCodeColor","status2","getTimestamp","now","Date","getHours","getMinutes","getSeconds","padStart","prepareRequest","objectToHeaders2","prepareResponse","responseHeaders","match","getCleanUrl","REDUNDANT_CHARACTERS_EXP","getSearchParams","cleanUrl","isAbsoluteUrl","getAbsoluteUrl","baseUrl","baseURI","decodeURI","encodeURI","normalizePath","maybeAbsoluteUrl","coercePath","_","parameterName","wildcard","expression","matchRequestUrl","normalizedPath","cleanPath","cleanUrl2","decode","decodeURIComponent","params","matches","Headers4","Headers3","compose","_len9","fns","_key9","reduceRight","leftFn","rightFn","NetworkError","defaultResponse","defaultResponseTransformers","createResponseComposition","responseOverrides","defaultTransformers","initialResponse","_len10","transformers","_key10","resolvedTransformers","Boolean","resolvedResponse","networkError","SOURCE_FRAME","BUILD_FRAME","getCallFrame","stack","frames","declarationFrame","frame","declarationPath","isIterable","fn","Symbol","iterator","defaultContext","RequestHandler","ctx","resolver","callFrame","info","_request","_resolutionContext","predicate","getPublicRequest","_parsedResult","shouldIntercept","executeResolver","wrapResolver","mockedResponse","createExecutionResult","req","resolverGenerator","done","next","nextResponse","resolverGeneratorResult","response2","restContext","RestRequest","RestHandler","header","checkRedundantQueryParameters","queryParams","paramName","push","matchesMethod","log","publicUrl","loggedRequest","loggedResponse","statusColor","groupCollapsed","groupEnd","invariant2","field","fieldName","fieldValue","validateFieldName","tryCatch","onException","graphqlContext","isDocumentNode","GraphQLRequest","GraphQLHandler","endpoint","resolvedOperationName","parsedNode","hasMatchingUrl","hasMatchingOperationType","hasMatchingOperationName","requestInfo","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groupHandlersByType","groups","graphql","getRestHandlerScore","Infinity","hasSameMethod","methodScoreDelta","score","getGraphQLHandlerScore","parsedQuery","hasSameOperationType","operationTypeScoreDelta","getSuggestedHandler","getScore","suggestedHandlers","suggestions","sort","_ref4","_ref5","leftScore","rightScore","_ref6","_ref7","getSuggestedHandlersMessage","onUnhandledRequest","strategy","parsedGraphQLQuery","generateHandlerSuggestion","handlerGroups","generateUnhandledRequestMessage","requestHeader","handlerSuggestion","messageTemplate","applyStrategy","strategy2","warning","bind","store2","readResponseCookies","add","persist","handleRequest","handleRequestOptions","_c","_d","_e","_f","onPassthroughResponse","lookupError","lookupResult","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","bold","DEFAULT_LISTEN_OPTIONS","SetupServerApi","interceptors","_len11","_key11","interceptor","Interceptor2","resolvedOptions","mockedRequest","arrayBuffer","response3","respondWith","listen","apply","APPLYING","APPLIED","readyState","printHandlers","pragma","hasOwnProperty","close","ClientRequestInterceptor","XMLHttpRequestInterceptor","FetchInterceptor","setupServer","_len12","_key12"],"sources":["/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/config/polyfills-node.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/node/SetupServerApi.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/SetupApi.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/devUtils.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/pipeEvents.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/toReadonlyArray.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/isObject.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/mergeRight.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/MockedRequest.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/getRequestCookies.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/jsonParse.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/parseMultipartData.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/parseBody.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/isStringEqual.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/handleRequest.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/getResponse.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/onUnhandledRequest.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/parseGraphQLRequest.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/getPublicUrlFromRequest.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/status.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/set.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/cookie.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/body.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/json.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/data.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/extensions.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/delay.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/errors.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/fetch.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/text.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/xml.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/logging/getStatusCodeColor.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/logging/getTimestamp.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/logging/prepareRequest.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/logging/prepareResponse.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/matching/matchRequestUrl.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/url/cleanUrl.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/url/isAbsoluteUrl.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/url/getAbsoluteUrl.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/matching/normalizePath.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/handlers/RequestHandler.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/response.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/compose.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/NetworkError.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/getCallFrame.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/isIterable.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/handlers/RestHandler.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/context/field.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/tryCatch.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/handlers/GraphQLHandler.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/readResponseCookies.ts","/Users/kyoungseo/Desktop/4//step2/kakao-gift5/react-product-login/node_modules/msw/src/node/setupServer.ts"],"sourcesContent":["import { setTimeout as nodeSetTimeout } from 'timers'\n\n// Polyfill the global \"setTimeout\" so MSW could be used\n// with \"jest.useFakeTimers()\". MSW response handling\n// is wrapped in \"setTimeout\", and without this polyfill\n// you'd have to manually advance the timers for the response\n// to finally resolve.\nexport const setTimeout = nodeSetTimeout\n","import chalk from 'chalk'\nimport { invariant } from 'outvariant'\nimport {\n  BatchInterceptor,\n  HttpRequestEventMap,\n  Interceptor,\n  InterceptorReadyState,\n  IsomorphicResponse,\n  MockedResponse as MockedInterceptedResponse,\n} from '@mswjs/interceptors'\nimport { SetupApi } from '../SetupApi'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { handleRequest } from '../utils/handleRequest'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { SetupServer } from './glossary'\n\n/**\n * @see https://github.com/mswjs/msw/pull/1399\n */\nconst { bold } = chalk\n\nexport type ServerLifecycleEventsMap = LifeCycleEventsMap<IsomorphicResponse>\n\nconst DEFAULT_LISTEN_OPTIONS: RequiredDeep<SharedOptions> = {\n  onUnhandledRequest: 'warn',\n}\n\nexport class SetupServerApi\n  extends SetupApi<ServerLifecycleEventsMap>\n  implements SetupServer\n{\n  protected readonly interceptor: BatchInterceptor<\n    Array<Interceptor<HttpRequestEventMap>>,\n    HttpRequestEventMap\n  >\n  private resolvedOptions: RequiredDeep<SharedOptions>\n\n  constructor(\n    interceptors: Array<{\n      new (): Interceptor<HttpRequestEventMap>\n    }>,\n    ...handlers: Array<RequestHandler>\n  ) {\n    super(...handlers)\n\n    this.interceptor = new BatchInterceptor({\n      name: 'setup-server',\n      interceptors: interceptors.map((Interceptor) => new Interceptor()),\n    })\n    this.resolvedOptions = {} as RequiredDeep<SharedOptions>\n\n    this.init()\n  }\n\n  /**\n   * Subscribe to all requests that are using the interceptor object\n   */\n  private init(): void {\n    this.interceptor.on('request', async (request) => {\n      const mockedRequest = new MockedRequest(request.url, {\n        ...request,\n        body: await request.arrayBuffer(),\n      })\n\n      const response = await handleRequest<\n        MockedInterceptedResponse & { delay?: number }\n      >(\n        mockedRequest,\n        this.currentHandlers,\n        this.resolvedOptions,\n        this.emitter,\n        {\n          transformResponse(response) {\n            return {\n              status: response.status,\n              statusText: response.statusText,\n              headers: response.headers.all(),\n              body: response.body,\n              delay: response.delay,\n            }\n          },\n        },\n      )\n\n      if (response) {\n        // Delay Node.js responses in the listener so that\n        // the response lookup logic is not concerned with responding\n        // in any way. The same delay is implemented in the worker.\n        if (response.delay) {\n          await new Promise((resolve) => {\n            setTimeout(resolve, response.delay)\n          })\n        }\n\n        request.respondWith(response)\n      }\n\n      return\n    })\n\n    this.interceptor.on('response', (request, response) => {\n      if (!request.id) {\n        return\n      }\n\n      if (response.headers.get('x-powered-by') === 'msw') {\n        this.emitter.emit('response:mocked', response, request.id)\n      } else {\n        this.emitter.emit('response:bypass', response, request.id)\n      }\n    })\n  }\n\n  public listen(options: Partial<SharedOptions> = {}): void {\n    this.resolvedOptions = mergeRight(\n      DEFAULT_LISTEN_OPTIONS,\n      options,\n    ) as RequiredDeep<SharedOptions>\n\n    // Apply the interceptor when starting the server.\n    this.interceptor.apply()\n\n    // Assert that the interceptor has been applied successfully.\n    // Also guards us from forgetting to call \"interceptor.apply()\"\n    // as a part of the \"listen\" method.\n    invariant(\n      [InterceptorReadyState.APPLYING, InterceptorReadyState.APPLIED].includes(\n        this.interceptor.readyState,\n      ),\n      devUtils.formatMessage(\n        'Failed to start \"setupServer\": the interceptor failed to apply. This is likely an issue with the library and you should report it at \"%s\".',\n      ),\n      'https://github.com/mswjs/msw/issues/new/choose',\n    )\n  }\n\n  public printHandlers(): void {\n    const handlers = this.listHandlers()\n\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info\n\n      const pragma = handler.info.hasOwnProperty('operationType')\n        ? '[graphql]'\n        : '[rest]'\n\n      console.log(`\\\n${bold(`${pragma} ${header}`)}\n  Declaration: ${callFrame}\n`)\n    })\n  }\n\n  public close(): void {\n    super.dispose()\n    this.interceptor.dispose()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { EventMap, Emitter } from 'strict-event-emitter'\nimport {\n  DefaultBodyType,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n} from './handlers/RequestHandler'\nimport { LifeCycleEventEmitter } from './sharedOptions'\nimport { devUtils } from './utils/internal/devUtils'\nimport { pipeEvents } from './utils/internal/pipeEvents'\nimport { toReadonlyArray } from './utils/internal/toReadonlyArray'\nimport { MockedRequest } from './utils/request/MockedRequest'\n\n/**\n * Generic class for the mock API setup.\n */\nexport abstract class SetupApi<EventsMap extends EventMap> {\n  protected initialHandlers: ReadonlyArray<RequestHandler>\n  protected currentHandlers: Array<RequestHandler>\n  protected readonly emitter: Emitter<EventsMap>\n  protected readonly publicEmitter: Emitter<EventsMap>\n\n  public readonly events: LifeCycleEventEmitter<EventsMap>\n\n  constructor(...initialHandlers: Array<RequestHandler>) {\n    this.validateHandlers(...initialHandlers)\n\n    this.initialHandlers = toReadonlyArray(initialHandlers)\n    this.currentHandlers = [...initialHandlers]\n\n    this.emitter = new Emitter<EventsMap>()\n    this.publicEmitter = new Emitter<EventsMap>()\n    pipeEvents(this.emitter, this.publicEmitter)\n\n    this.events = this.createLifeCycleEvents()\n  }\n\n  private validateHandlers(...handlers: ReadonlyArray<RequestHandler>): void {\n    // Guard against incorrect call signature of the setup API.\n    for (const handler of handlers) {\n      invariant(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.',\n        ),\n        this.constructor.name,\n      )\n    }\n  }\n\n  protected dispose(): void {\n    this.emitter.removeAllListeners()\n    this.publicEmitter.removeAllListeners()\n  }\n\n  public use(...runtimeHandlers: Array<RequestHandler>): void {\n    this.currentHandlers.unshift(...runtimeHandlers)\n  }\n\n  public restoreHandlers(): void {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false)\n    })\n  }\n\n  public resetHandlers(...nextHandlers: Array<RequestHandler>): void {\n    this.currentHandlers =\n      nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers]\n  }\n\n  public listHandlers(): ReadonlyArray<\n    RequestHandler<\n      RequestHandlerDefaultInfo,\n      MockedRequest<DefaultBodyType>,\n      any,\n      MockedRequest<DefaultBodyType>\n    >\n  > {\n    return toReadonlyArray(this.currentHandlers)\n  }\n\n  private createLifeCycleEvents(): LifeCycleEventEmitter<EventsMap> {\n    return {\n      on: (...args: any[]) => {\n        return (this.publicEmitter.on as any)(...args)\n      },\n      removeListener: (...args: any[]) => {\n        return (this.publicEmitter.removeListener as any)(...args)\n      },\n      removeAllListeners: (...args: any[]) => {\n        return this.publicEmitter.removeAllListeners(...args)\n      },\n    }\n  }\n\n  abstract printHandlers(): void\n}\n","import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents<Events extends EventMap>(\n  source: Emitter<Events>,\n  destination: Emitter<Events>,\n): void {\n  const rawEmit = source.emit\n\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  source.emit = function (event, ...data) {\n    destination.emit(event, ...data)\n    return rawEmit.call(this, event, ...data)\n  }\n\n  // @ts-ignore\n  source.emit._isPiped = true\n}\n","/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key]\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue)\n      return result\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue)\n      return result\n    }\n\n    result[key] = rightValue\n    return result\n  }, Object.assign({}, left))\n}\n","import * as cookieUtils from 'cookie'\nimport { store } from '@mswjs/cookies'\nimport { IsomorphicRequest, RequestInit } from '@mswjs/interceptors'\nimport { decodeBuffer } from '@mswjs/interceptors/lib/utils/bufferUtils.js'\nimport { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from '../../handlers/RequestHandler'\nimport { MockedResponse } from '../../response'\nimport { getRequestCookies } from './getRequestCookies'\nimport { parseBody } from './parseBody'\nimport { isStringEqual } from '../internal/isStringEqual'\n\nexport type RequestCache =\n  | 'default'\n  | 'no-store'\n  | 'reload'\n  | 'no-cache'\n  | 'force-cache'\n  | 'only-if-cached'\n\nexport type RequestMode = 'navigate' | 'same-origin' | 'no-cors' | 'cors'\n\nexport type RequestRedirect = 'follow' | 'error' | 'manual'\n\nexport type RequestDestination =\n  | ''\n  | 'audio'\n  | 'audioworklet'\n  | 'document'\n  | 'embed'\n  | 'font'\n  | 'frame'\n  | 'iframe'\n  | 'image'\n  | 'manifest'\n  | 'object'\n  | 'paintworklet'\n  | 'report'\n  | 'script'\n  | 'sharedworker'\n  | 'style'\n  | 'track'\n  | 'video'\n  | 'xslt'\n  | 'worker'\n\nexport type RequestPriority = 'high' | 'low' | 'auto'\n\nexport type RequestReferrerPolicy =\n  | ''\n  | 'no-referrer'\n  | 'no-referrer-when-downgrade'\n  | 'origin'\n  | 'origin-when-cross-origin'\n  | 'same-origin'\n  | 'strict-origin'\n  | 'strict-origin-when-cross-origin'\n  | 'unsafe-url'\n\nexport interface MockedRequestInit extends RequestInit {\n  id?: string\n  cache?: RequestCache\n  redirect?: RequestRedirect\n  integrity?: string\n  keepalive?: boolean\n  mode?: RequestMode\n  priority?: RequestPriority\n  destination?: RequestDestination\n  referrer?: string\n  referrerPolicy?: RequestReferrerPolicy\n  cookies?: Record<string, string>\n}\n\nexport class MockedRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n> extends IsomorphicRequest {\n  public readonly cache: RequestCache\n  public readonly cookies: Record<string, string>\n  public readonly destination: RequestDestination\n  public readonly integrity: string\n  public readonly keepalive: boolean\n  public readonly mode: RequestMode\n  public readonly priority: RequestPriority\n  public readonly redirect: RequestRedirect\n  public readonly referrer: string\n  public readonly referrerPolicy: RequestReferrerPolicy\n\n  constructor(url: URL, init: MockedRequestInit = {}) {\n    super(url, init)\n    if (init.id) {\n      this.id = init.id\n    }\n    this.cache = init.cache || 'default'\n    this.destination = init.destination || ''\n    this.integrity = init.integrity || ''\n    this.keepalive = init.keepalive || false\n    this.mode = init.mode || 'cors'\n    this.priority = init.priority || 'auto'\n    this.redirect = init.redirect || 'follow'\n    this.referrer = init.referrer || ''\n    this.referrerPolicy = init.referrerPolicy || 'no-referrer'\n    this.cookies = init.cookies || this.getCookies()\n  }\n\n  /**\n   * Get parsed request body. The type is inferred from the content type.\n   *\n   * @deprecated - Use `req.text()`, `req.json()` or `req.arrayBuffer()`\n   * to read the request body as a plain text, JSON, or ArrayBuffer.\n   */\n  public get body(): RequestBody {\n    const text = decodeBuffer(this['_body'])\n\n    /**\n     * @deprecated https://github.com/mswjs/msw/issues/1318\n     * @fixme Remove this assumption and let the users read\n     * request body explicitly using \".json()\"/\".text()\"/\".arrayBuffer()\".\n     */\n    // Parse the request's body based on the \"Content-Type\" header.\n    const body = parseBody(text, this.headers)\n\n    if (isStringEqual(this.method, 'GET') && body === '') {\n      return undefined as RequestBody\n    }\n\n    return body as RequestBody\n  }\n\n  /**\n   * Bypass the intercepted request.\n   * This will make a call to the actual endpoint requested.\n   */\n  public passthrough(): MockedResponse<null> {\n    return {\n      // Constructing a dummy \"101 Continue\" mocked response\n      // to keep the return type of the resolver consistent.\n      status: 101,\n      statusText: 'Continue',\n      headers: new Headers(),\n      body: null,\n      // Setting \"passthrough\" to true will signal the response pipeline\n      // to perform this intercepted request as-is.\n      passthrough: true,\n      once: false,\n    }\n  }\n\n  private getCookies(): Record<string, string> {\n    // Parse the cookies passed in the original request \"cookie\" header.\n    const requestCookiesString = this.headers.get('cookie')\n    const ownCookies = requestCookiesString\n      ? cookieUtils.parse(requestCookiesString)\n      : {}\n\n    store.hydrate()\n\n    const cookiesFromStore = Array.from(\n      store.get({ ...this, url: this.url.href })?.entries(),\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value })\n    }, {})\n\n    // Get existing document cookies that are applicable\n    // to this request based on its \"credentials\" policy.\n    const cookiesFromDocument = getRequestCookies(this)\n\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore,\n    }\n\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append('cookie', `${name}=${value}`)\n    }\n\n    return {\n      ...forwardedCookies,\n      ...ownCookies,\n    }\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { MockedRequest } from './MockedRequest'\n\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie)\n}\n\n/**\n * Returns relevant document cookies based on the request `credentials` option.\n */\nexport function getRequestCookies(request: MockedRequest) {\n  /**\n   * @note No cookies persist on the document in Node.js: no document.\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === request.url.origin ? getAllCookies() : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n","/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return undefined\n  }\n}\n","import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n","import { jsonParse } from '../internal/jsonParse'\nimport { parseMultipartData } from '../internal/parseMultipartData'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Parses a given request/response body based on the \"Content-Type\" header.\n */\nexport function parseBody(body?: MockedRequest['body'], headers?: Headers) {\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body\n  }\n\n  const contentType = headers?.get('content-type')?.toLowerCase() || ''\n\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data')\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body\n  }\n\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json')\n\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body\n  }\n\n  // Otherwise leave as-is.\n  return body\n}\n","/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n","import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { ServerLifecycleEventsMap } from '../node/glossary'\nimport { MockedResponse } from '../response'\nimport { SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { devUtils } from './internal/devUtils'\nimport { MockedRequest } from './request/MockedRequest'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions<ResponseType> {\n  /**\n   * Options for the response resolution process.\n   */\n  resolutionContext?: {\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: MockedResponse<string>): ResponseType\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: MockedRequest): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest<\n  ResponseType extends Record<string, any> = MockedResponse<string>,\n>(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<ServerLifecycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions<ResponseType>,\n): Promise<ResponseType | undefined> {\n  emitter.emit('request:start', request)\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions?.resolutionContext,\n    )\n  })\n\n  if (lookupError) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', lookupError, request)\n    throw lookupError\n  }\n\n  const { handler, response } = lookupResult\n\n  // When there's no handler for the request, consider it unhandled.\n  // Allow the developer to react to such cases.\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', request)\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    devUtils.warn(\n      `\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`,\n      response,\n      handler.info.header,\n      handler.info.callFrame,\n    )\n\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the developer explicitly returned \"req.passthrough()\" do not warn them.\n  // Perform the request as-is.\n  if (response.passthrough) {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', request)\n\n  const requiredLookupResult =\n    lookupResult as RequiredDeep<ResponseLookupResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as ResponseType)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', request)\n\n  return transformedResponse\n}\n","import { MockedResponse } from '../response'\nimport {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\nimport { MockedRequest } from './request/MockedRequest'\n\nexport interface ResponseLookupResult {\n  handler?: RequestHandler\n  publicRequest?: any\n  parsedRequest?: any\n  response?: MockedResponse\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <\n  Request extends MockedRequest,\n  Handler extends RequestHandler[],\n>(\n  request: Request,\n  handlers: Handler,\n  resolutionContext?: ResponseResolutionContext,\n): Promise<ResponseLookupResult> => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext)\n  })\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  const result = await relevantHandlers.reduce<\n    Promise<RequestHandlerExecutionResult<any> | null>\n  >(async (executionResult, handler) => {\n    const previousResults = await executionResult\n\n    if (!!previousResults?.response) {\n      return executionResult\n    }\n\n    const result = await handler.run(request, resolutionContext)\n\n    if (result === null || result.handler.shouldSkip) {\n      return null\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult,\n      }\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true)\n    }\n\n    return result\n  }, Promise.resolve(null))\n\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response,\n  }\n}\n","import getStringMatchScore from 'js-levenshtein'\nimport {\n  ParsedGraphQLQuery,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { RestHandler } from '../../handlers/RestHandler'\nimport { GraphQLHandler } from '../../handlers/GraphQLHandler'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { tryCatch } from '../internal/tryCatch'\nimport { devUtils } from '../internal/devUtils'\nimport { MockedRequest } from './MockedRequest'\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: MockedRequest,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  rest: RestHandler[]\n  graphql: GraphQLHandler[]\n}\n\nfunction groupHandlersByType(handlers: RequestHandler[]): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      rest: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: MockedRequest,\n  handler: RequestHandlerType,\n) => number\n\nfunction getRestHandlerScore(): ScoreGetterFn<RestHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: MockedRequest,\n  handlers: RestHandler[] | GraphQLHandler[],\n  getScore: ScoreGetterFn<RestHandler> | ScoreGetterFn<GraphQLHandler>,\n): RequestHandler[] {\n  const suggestedHandlers = (handlers as RequestHandler[])\n    .reduce<RequestHandlerSuggestion[]>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `   ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport function onUnhandledRequest(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  strategy: UnhandledRequestStrategy = 'warn',\n): void {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request))\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.rest\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getRestHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const requestHeader = parsedGraphQLQuery\n      ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import type {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n} from 'graphql'\nimport { parse } from 'graphql'\nimport { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../request/MockedRequest'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n  return operations.variables\n}\n\nfunction getGraphQLInput(request: MockedRequest<any>): GraphQLInput | null {\n  switch (request.method) {\n    case 'GET': {\n      const query = request.url.searchParams.get('query')\n      const variables = request.url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      if (request.body?.query) {\n        const { query, variables } = request.body\n\n        return {\n          query,\n          variables,\n        }\n      }\n\n      // Handle multipart body operations.\n      if (request.body?.operations) {\n        const { operations, map, ...files } =\n          request.body as GraphQLMultipartRequestBody\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport function parseGraphQLRequest(\n  request: MockedRequest<any>,\n): ParsedGraphQLRequest {\n  const input = getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return undefined\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n","import { MockedRequest } from './MockedRequest'\n\n/**\n * Returns a relative URL if the given request URL is relative to the current origin.\n * Otherwise returns an absolute URL.\n */\nexport const getPublicUrlFromRequest = (request: MockedRequest) => {\n  return request.referrer.startsWith(request.url.origin)\n    ? request.url.pathname\n    : new URL(\n        request.url.pathname,\n        `${request.url.protocol}//${request.url.host}`,\n      ).href\n}\n","import statuses from 'statuses/codes.json'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a response status code and text.\n * @example\n * res(ctx.status(301))\n * res(ctx.status(400, 'Custom status text'))\n * @see {@link https://mswjs.io/docs/api/context/status `ctx.status()`}\n */\nexport const status = (\n  statusCode: number,\n  statusText?: string,\n): ResponseTransformer => {\n  return (res) => {\n    res.status = statusCode\n    res.statusText =\n      statusText || statuses[String(statusCode) as keyof typeof statuses]\n\n    return res\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { ResponseTransformer } from '../response'\n\nexport type HeadersObject<KeyType extends string = string> = Record<\n  KeyType,\n  string | string[]\n>\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n */\nexport type ForbiddenHeaderNames =\n  | 'cookie'\n  | 'cookie2'\n  | 'set-cookie'\n  | 'set-cookie2'\n\nexport type ForbiddenHeaderError<HeaderName extends string> =\n  `SafeResponseHeader: the '${HeaderName}' header cannot be set on the response. Please use the 'ctx.cookie()' function instead.`\n\n/**\n * Sets one or multiple response headers.\n * @example\n * ctx.set('Content-Type', 'text/plain')\n * ctx.set({\n *   'Accept': 'application/javascript',\n *   'Content-Type': \"text/plain\"\n * })\n * @see {@link https://mswjs.io/docs/api/context/set `ctx.set()`}\n */\nexport function set<N extends string | HeadersObject>(\n  ...args: N extends string\n    ? Lowercase<N> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<N>]\n      : [N, string]\n    : N extends HeadersObject<infer CookieName>\n    ? Lowercase<CookieName> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<CookieName>]\n      : [N]\n    : [N]\n): ResponseTransformer {\n  return (res) => {\n    const [name, value] = args\n\n    if (typeof name === 'string') {\n      res.headers.append(name, value as string)\n    } else {\n      const headers = objectToHeaders(name)\n      headers.forEach((value, name) => {\n        res.headers.append(name, value)\n      })\n    }\n\n    return res\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a given cookie on the mocked response.\n * @example res(ctx.cookie('name', 'value'))\n */\nexport const cookie = (\n  name: string,\n  value: string,\n  options?: cookieUtils.CookieSerializeOptions,\n): ResponseTransformer => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options)\n    res.headers.append('Set-Cookie', serializedCookie)\n\n    if (typeof document !== 'undefined') {\n      document.cookie = serializedCookie\n    }\n\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a raw response body. Does not append any `Content-Type` headers.\n * @example\n * res(ctx.body('Successful response'))\n * res(ctx.body(JSON.stringify({ key: 'value' })))\n * @see {@link https://mswjs.io/docs/api/context/body `ctx.body()`}\n */\nexport const body = <\n  BodyType extends string | Blob | BufferSource | ReadableStream | FormData,\n>(\n  value: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.body = value\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets the given value as the JSON body of the response.\n * Appends a `Content-Type: application/json` header on the\n * mocked response.\n * @example\n * res(ctx.json('Some string'))\n * res(ctx.json({ key: 'value' }))\n * res(ctx.json([1, '2', false, { ok: true }]))\n * @see {@link https://mswjs.io/docs/api/context/json `ctx.json()`}\n */\nexport const json = <BodyTypeJSON>(\n  body: BodyTypeJSON,\n): ResponseTransformer<BodyTypeJSON> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'application/json')\n    res.body = JSON.stringify(body) as any\n\n    return res\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets a given payload as a GraphQL response body.\n * @example\n * res(ctx.data({ user: { firstName: 'John' }}))\n * @see {@link https://mswjs.io/docs/api/context/data `ctx.data()`}\n */\nexport const data: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { data: payload })\n\n    return json(nextBody)(res)\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets the GraphQL extensions on a given response.\n * @example\n * res(ctx.extensions({ tracing: { version: 1 }}))\n * @see {@link https://mswjs.io/docs/api/context/extensions `ctx.extensions()`}\n */\nexport const extensions: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { extensions: payload })\n    return json(nextBody)(res)\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { ResponseTransformer } from '../response'\n\nexport const SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647\nexport const MIN_SERVER_RESPONSE_TIME = 100\nexport const MAX_SERVER_RESPONSE_TIME = 400\nexport const NODE_SERVER_RESPONSE_TIME = 5\n\nconst getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME\n  }\n\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +\n      MIN_SERVER_RESPONSE_TIME,\n  )\n}\n\nexport type DelayMode = 'real' | 'infinite'\n\n/**\n * Delays the response by the given duration (ms).\n * @example\n * res(ctx.delay(1200)) // delay response by 1200ms\n * res(ctx.delay()) // emulate realistic server response time\n * res(ctx.delay('infinite')) // delay response infinitely\n * @see {@link https://mswjs.io/docs/api/context/delay `ctx.delay()`}\n */\nexport const delay = (\n  durationOrMode?: DelayMode | number,\n): ResponseTransformer => {\n  return (res) => {\n    let delayTime: number\n\n    if (typeof durationOrMode === 'string') {\n      switch (durationOrMode) {\n        case 'infinite': {\n          // Using `Infinity` as a delay value executes the response timeout immediately.\n          // Instead, use the maximum allowed integer for `setTimeout`.\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT\n          break\n        }\n        case 'real': {\n          delayTime = getRandomServerResponseTime()\n          break\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`,\n          )\n        }\n      }\n    } else if (typeof durationOrMode === 'undefined') {\n      // Use random realistic server response time when no explicit delay duration was provided.\n      delayTime = getRandomServerResponseTime()\n    } else {\n      // Guard against passing values like `Infinity` or `Number.MAX_VALUE`\n      // as the response delay duration. They don't produce the result you may expect.\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`,\n        )\n      }\n\n      delayTime = durationOrMode\n    }\n\n    res.delay = delayTime\n    return res\n  }\n}\n","import type { GraphQLError } from 'graphql'\nimport { ResponseTransformer } from '../response'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\n/**\n * Sets a given list of GraphQL errors on the mocked response.\n * @example res(ctx.errors([{ message: 'Unauthorized' }]))\n * @see {@link https://mswjs.io/docs/api/context/errors}\n */\nexport const errors = <\n  ErrorsType extends readonly Partial<GraphQLError>[] | null | undefined,\n>(\n  errorsList: ErrorsType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    if (errorsList == null) {\n      return res\n    }\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { errors: errorsList })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { Headers } from 'headers-polyfill'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nconst useFetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n  isNodeProcess()\n    ? (input, init) =>\n        import('node-fetch').then(({ default: nodeFetch }) =>\n          (nodeFetch as unknown as typeof window.fetch)(input, init),\n        )\n    : globalThis.fetch\n\nexport const augmentRequestInit = (requestInit: RequestInit): RequestInit => {\n  const headers = new Headers(requestInit.headers)\n  headers.set('x-msw-bypass', 'true')\n\n  return {\n    ...requestInit,\n    headers: headers.all(),\n  }\n}\n\nconst createFetchRequestParameters = (input: MockedRequest): RequestInit => {\n  const { body, method } = input\n  const requestParameters: RequestInit = {\n    ...input,\n    body: undefined,\n  }\n\n  if (['GET', 'HEAD'].includes(method)) {\n    return requestParameters\n  }\n\n  if (\n    typeof body === 'object' ||\n    typeof body === 'number' ||\n    typeof body === 'boolean'\n  ) {\n    requestParameters.body = JSON.stringify(body)\n  } else {\n    requestParameters.body = body\n  }\n\n  return requestParameters\n}\n\n/**\n * Performs a bypassed request inside a request handler.\n * @example\n * const originalResponse = await ctx.fetch(req)\n * @see {@link https://mswjs.io/docs/api/context/fetch `ctx.fetch()`}\n */\nexport const fetch = (\n  input: string | MockedRequest,\n  requestInit: RequestInit = {},\n): Promise<Response> => {\n  if (typeof input === 'string') {\n    return useFetch(input, augmentRequestInit(requestInit))\n  }\n\n  const requestParameters = createFetchRequestParameters(input)\n  const derivedRequestInit = augmentRequestInit(requestParameters)\n\n  return useFetch(input.url.href, derivedRequestInit)\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a textual response body. Appends a `Content-Type: text/plain`\n * header on the mocked response.\n * @example res(ctx.text('Successful response'))\n * @see {@link https://mswjs.io/docs/api/context/text `ctx.text()`}\n */\nexport const text = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/plain')\n    res.body = body\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets an XML response body. Appends a `Content-Type: text/xml` header\n * on the mocked response.\n * @example\n * res(ctx.xml('<node key=\"value\">Content</node>'))\n * @see {@link https://mswjs.io/docs/api/context/xml `ctx.xml()`}\n */\nexport const xml = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/xml')\n    res.body = body\n    return res\n  }\n}\n","export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n","/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(): string {\n  const now = new Date()\n\n  return [now.getHours(), now.getMinutes(), now.getSeconds()]\n    .map(String)\n    .map((chunk) => chunk.slice(0, 2))\n    .map((chunk) => chunk.padStart(2, '0'))\n    .join(':')\n}\n","import type { DefaultBodyType } from '../../handlers/RequestHandler.js'\nimport type { MockedRequest } from '../request/MockedRequest.js'\n\nexport interface LoggedRequest {\n  id: string\n  url: URL\n  method: string\n  headers: Record<string, string>\n  cookies: Record<string, string>\n  body: DefaultBodyType\n}\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport function prepareRequest(request: MockedRequest): LoggedRequest {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all(),\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { SerializedResponse } from '../../setupWorker/glossary'\nimport { parseBody } from '../request/parseBody'\n\n/**\n * Formats a mocked response for introspection in the browser's console.\n */\nexport function prepareResponse(res: SerializedResponse<string>) {\n  const responseHeaders = objectToHeaders(res.headers)\n\n  // Parse a response JSON body for preview in the logs\n  const parsedBody = parseBody(res.body, responseHeaders)\n\n  return {\n    ...res,\n    body: parsedBody,\n  }\n}\n","import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl.js'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n","const REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes query parameters and hashes from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n","/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n","import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin =\n    baseUrl || (typeof document !== 'undefined' && document.baseURI)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n","import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n","import { Headers } from 'headers-polyfill'\nimport {\n  MaybePromise,\n  MockedResponse,\n  response,\n  ResponseComposition,\n} from '../response'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport { status } from '../context/status'\nimport { set } from '../context/set'\nimport { delay } from '../context/delay'\nimport { fetch } from '../context/fetch'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type DefaultContext = {\n  status: typeof status\n  set: typeof set\n  delay: typeof delay\n  fetch: typeof fetch\n}\n\nexport const defaultContext: DefaultContext = {\n  status,\n  set,\n  delay,\n  fetch,\n}\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | (string | File)[]\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\ntype ContextMap = Record<string, (...args: any[]) => any>\n\nexport type ResponseResolverReturnType<ReturnType> =\n  | ReturnType\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<ReturnType> = MaybePromise<\n  ResponseResolverReturnType<ReturnType>\n>\n\nexport type AsyncResponseResolverReturnType<ReturnType> =\n  | MaybeAsyncResponseResolverReturnType<ReturnType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>\n    >\n\nexport type ResponseResolver<\n  RequestType = MockedRequest,\n  ContextType = typeof defaultContext,\n  BodyType extends DefaultBodyType = any,\n> = (\n  req: RequestType,\n  res: ResponseComposition<BodyType>,\n  context: ContextType,\n) => AsyncResponseResolverReturnType<MockedResponse<BodyType>>\n\nexport interface RequestHandlerOptions<HandlerInfo> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any, any>\n  ctx?: ContextMap\n}\n\nexport interface RequestHandlerExecutionResult<PublicRequestType> {\n  handler: RequestHandler\n  parsedResult: any\n  request: PublicRequestType\n  response?: MockedResponse\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  Request extends MockedRequest = MockedRequest,\n  ParsedResult = any,\n  PublicRequest extends MockedRequest = Request,\n> {\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  public shouldSkip: boolean\n\n  private ctx: ContextMap\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: MaybeAsyncResponseResolverReturnType<any>\n\n  protected resolver: ResponseResolver<any, any>\n\n  constructor(options: RequestHandlerOptions<HandlerInfo>) {\n    this.shouldSkip = false\n    this.ctx = options.ctx || defaultContext\n    this.resolver = options.resolver\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...options.info,\n      callFrame,\n    }\n  }\n\n  /**\n   * Determine if the captured request should be mocked.\n   */\n  abstract predicate(\n    request: MockedRequest,\n    parsedResult: ParsedResult,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedResult: ParsedResult,\n  ): void\n\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(\n    _request: MockedRequest,\n    _resolutionContext?: ResponseResolutionContext,\n  ): ParsedResult {\n    return null as any\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   */\n  public test(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext,\n    )\n  }\n\n  /**\n   * Derive the publicly exposed request (`req`) instance of the response resolver\n   * from the captured request and its parsed result.\n   */\n  protected getPublicRequest(\n    request: MockedRequest,\n    _parsedResult: ParsedResult,\n  ) {\n    return request as PublicRequest\n  }\n\n  public markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): Promise<RequestHandlerExecutionResult<PublicRequest> | null> {\n    if (this.shouldSkip) {\n      return null\n    }\n\n    const parsedResult = this.parse(request, resolutionContext)\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext,\n    )\n\n    if (!shouldIntercept) {\n      return null\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult)\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx,\n    )\n\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse,\n    )\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<any, any>,\n  ): ResponseResolver<AsyncResponseResolverReturnType<any>, any> {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        this.resolverGeneratorResult = nextResponse\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(\n    parsedResult: ParsedResult,\n    request: PublicRequest,\n    response: any,\n  ): RequestHandlerExecutionResult<PublicRequest> {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null,\n    }\n  }\n}\n\n/**\n * Bypass this intercepted request.\n * This will make a call to the actual endpoint requested.\n */\nexport function passthrough(): MockedResponse<null> {\n  // Constructing a dummy \"101 Continue\" mocked response\n  // to keep the return type of the resolver consistent.\n  return {\n    status: 101,\n    statusText: 'Continue',\n    headers: new Headers(),\n    body: null,\n    // Setting \"passthrough\" to true will signal the response pipeline\n    // to perform this intercepted request as-is.\n    passthrough: true,\n    once: false,\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from './handlers/RequestHandler'\nimport { compose } from './utils/internal/compose'\nimport { NetworkError } from './utils/NetworkError'\n\nexport type MaybePromise<ValueType = any> = ValueType | Promise<ValueType>\n\n/**\n * Internal representation of a mocked response instance.\n */\nexport interface MockedResponse<BodyType extends DefaultBodyType = any> {\n  body: BodyType\n  status: number\n  statusText: string\n  headers: Headers\n  once: boolean\n  passthrough: boolean\n  delay?: number\n}\n\nexport type ResponseTransformer<\n  BodyType extends TransformerBodyType = any,\n  TransformerBodyType extends DefaultBodyType = any,\n> = (\n  res: MockedResponse<TransformerBodyType>,\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseFunction<BodyType extends DefaultBodyType = any> = (\n  ...transformers: ResponseTransformer<BodyType>[]\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseComposition<BodyType extends DefaultBodyType = any> =\n  ResponseFunction<BodyType> & {\n    /**\n     * Respond using a given mocked response to the first captured request.\n     * Does not affect any subsequent captured requests.\n     */\n    once: ResponseFunction<BodyType>\n    networkError: (message: string) => void\n  }\n\nexport const defaultResponse: Omit<MockedResponse, 'headers'> = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false,\n}\n\nexport type ResponseCompositionOptions<BodyType> = {\n  defaultTransformers?: ResponseTransformer<BodyType>[]\n  mockedResponseOverrides?: Partial<MockedResponse>\n}\n\nexport const defaultResponseTransformers: ResponseTransformer<any>[] = []\n\nexport function createResponseComposition<BodyType extends DefaultBodyType>(\n  responseOverrides?: Partial<MockedResponse<BodyType>>,\n  defaultTransformers: ResponseTransformer<BodyType>[] = defaultResponseTransformers,\n): ResponseFunction {\n  return async (...transformers) => {\n    const initialResponse: MockedResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new Headers({\n          'x-powered-by': 'msw',\n        }),\n      },\n      responseOverrides,\n    )\n\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers,\n    ].filter(Boolean)\n\n    const resolvedResponse =\n      resolvedTransformers.length > 0\n        ? compose(...resolvedTransformers)(initialResponse)\n        : initialResponse\n\n    return resolvedResponse\n  }\n}\n\nexport const response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message: string) {\n    throw new NetworkError(message)\n  },\n})\n","type ArityOneFunction = (arg: any) => any\n\ntype LengthOfTuple<Tuple extends any[]> = Tuple extends { length: infer L }\n  ? L\n  : never\n\ntype DropFirstInTuple<Tuple extends any[]> = ((...args: Tuple) => any) extends (\n  arg: any,\n  ...rest: infer LastArg\n) => any\n  ? LastArg\n  : Tuple\n\ntype LastInTuple<Tuple extends any[]> = Tuple[LengthOfTuple<\n  DropFirstInTuple<Tuple>\n>]\n\ntype FirstFnParameterType<Functions extends ArityOneFunction[]> = Parameters<\n  LastInTuple<Functions>\n>[any]\n\ntype LastFnParameterType<Functions extends ArityOneFunction[]> = ReturnType<\n  Functions[0]\n>\n\n/**\n * Composes a given list of functions into a new function that\n * executes from right to left.\n */\nexport function compose<\n  Functions extends ArityOneFunction[],\n  LeftReturnType extends FirstFnParameterType<Functions>,\n  RightReturnType extends LastFnParameterType<Functions>,\n>(\n  ...fns: Functions\n): (\n  ...args: [LeftReturnType] extends [never] ? never[] : [LeftReturnType]\n) => RightReturnType {\n  return (...args) => {\n    return fns.reduceRight((leftFn: any, rightFn) => {\n      return leftFn instanceof Promise\n        ? Promise.resolve(leftFn).then(rightFn)\n        : rightFn(leftFn)\n    }, args[0])\n  }\n}\n","export class NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n","// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n","/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n","import { body, cookie, json, text, xml } from '../context'\nimport type { SerializedResponse } from '../setupWorker/glossary'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport {\n  Match,\n  matchRequestUrl,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  DefaultBodyType,\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype RestHandlerMethod = string | RegExp\n\nexport interface RestHandlerInfo extends RequestHandlerDefaultInfo {\n  method: RestHandlerMethod\n  path: Path\n}\n\nexport enum RESTMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\n// Declaring a context interface infers\n// JSDoc description of the referenced utils.\nexport type RestContext = DefaultContext & {\n  cookie: typeof cookie\n  text: typeof text\n  body: typeof body\n  json: typeof json\n  xml: typeof xml\n}\n\nexport const restContext: RestContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml,\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport type ParsedRestRequest = Match\n\nexport class RestRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n  RequestParams extends PathParams = PathParams,\n> extends MockedRequest<RequestBody> {\n  constructor(\n    request: MockedRequest<RequestBody>,\n    public readonly params: RequestParams,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * @deprecated https://github.com/mswjs/msw/issues/1318\n       * @note Use internal request body buffer as the body init\n       * because \"request.body\" is a getter that will trigger\n       * request body parsing at this step.\n       */\n      body: request['_body'],\n    })\n    this.id = request.id\n  }\n}\n\n/**\n * Request handler for REST API requests.\n * Provides request matching based on method and URL.\n */\nexport class RestHandler<\n  RequestType extends MockedRequest<DefaultBodyType> = MockedRequest<DefaultBodyType>,\n> extends RequestHandler<\n  RestHandlerInfo,\n  RequestType,\n  ParsedRestRequest,\n  RestRequest<\n    RequestType extends MockedRequest<infer RequestBodyType>\n      ? RequestBodyType\n      : any,\n    PathParams\n  >\n> {\n  constructor(\n    method: RestHandlerMethod,\n    path: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method,\n      },\n      ctx: restContext,\n      resolver,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (path instanceof RegExp) {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: string[] = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`,\n    )\n  }\n\n  parse(request: RequestType, resolutionContext?: ResponseResolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext?.baseUrl,\n    )\n  }\n\n  protected getPublicRequest(\n    request: RequestType,\n    parsedResult: ParsedRestRequest,\n  ): RestRequest<any, PathParams> {\n    return new RestRequest(request, parsedResult.params || {})\n  }\n\n  predicate(request: RequestType, parsedResult: ParsedRestRequest) {\n    const matchesMethod =\n      this.info.method instanceof RegExp\n        ? this.info.method.test(request.method)\n        : isStringEqual(this.info.method, request.method)\n\n    return matchesMethod && parsedResult.matches\n  }\n\n  log(request: RequestType, response: SerializedResponse<any>) {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s %s (%c%s%c)'),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { ResponseTransformer } from '../response'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\ntype ForbiddenFieldNames = '' | 'data' | 'errors' | 'extensions'\n\n/**\n * Set a custom field on the GraphQL mocked response.\n * @example res(ctx.fields('customField', value))\n * @see {@link https://mswjs.io/docs/api/context/field}\n */\nexport const field = <FieldNameType extends string, FieldValueType>(\n  fieldName: FieldNameType extends ForbiddenFieldNames ? never : FieldNameType,\n  fieldValue: FieldValueType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    validateFieldName(fieldName)\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n\nfunction validateFieldName(fieldName: string) {\n  invariant(\n    fieldName.trim() !== '',\n    devUtils.formatMessage(\n      'Failed to set a custom field on a GraphQL response: field name cannot be empty.',\n    ),\n  )\n\n  invariant(\n    fieldName !== 'data',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'errors',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'extensions',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName,\n    ),\n  )\n}\n","export function tryCatch<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  onException?: (error: Error) => void,\n): ReturnType<Fn> | undefined {\n  try {\n    const result = fn()\n    return result\n  } catch (error) {\n    onException?.(error as Error)\n  }\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { data } from '../context/data'\nimport { extensions } from '../context/extensions'\nimport { errors } from '../context/errors'\nimport { field } from '../context/field'\nimport { GraphQLPayloadContext } from '../typeUtils'\nimport { cookie } from '../context/cookie'\nimport {\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport { matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { tryCatch } from '../utils/internal/tryCatch'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\n// GraphQL related context should contain utility functions\n// useful for GraphQL. Functions like `xml()` bear no value\n// in the GraphQL universe.\nexport type GraphQLContext<QueryType extends Record<string, unknown>> =\n  DefaultContext & {\n    data: GraphQLPayloadContext<QueryType>\n    extensions: GraphQLPayloadContext<QueryType>\n    errors: typeof errors\n    cookie: typeof cookie\n    field: typeof field\n  }\n\nexport const graphqlContext: GraphQLContext<any> = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field,\n}\n\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLRequest<\n  Variables extends GraphQLVariables,\n> extends MockedRequest<GraphQLRequestBody<Variables>> {\n  constructor(\n    request: MockedRequest,\n    public readonly variables: Variables,\n    public readonly operationName: string,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * TODO(https://github.com/mswjs/msw/issues/1318): Cleanup\n       */\n      body: request['_body'],\n    })\n  }\n}\n\nexport class GraphQLHandler<\n  Request extends GraphQLRequest<any> = GraphQLRequest<any>,\n> extends RequestHandler<\n  GraphQLHandlerInfo,\n  Request,\n  ParsedGraphQLRequest | null,\n  GraphQLRequest<any>\n> {\n  private endpoint: Path\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      ctx: graphqlContext,\n      resolver,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  parse(request: MockedRequest) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error) => console.error(error.message),\n    )\n  }\n\n  protected getPublicRequest(\n    request: Request,\n    parsedResult: ParsedGraphQLRequest,\n  ): GraphQLRequest<any> {\n    return new GraphQLRequest(\n      request,\n      parsedResult?.variables ?? {},\n      parsedResult?.operationName ?? '',\n    )\n  }\n\n  predicate(request: MockedRequest, parsedResult: ParsedGraphQLRequest) {\n    if (!parsedResult) {\n      return false\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = getPublicUrlFromRequest(request)\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation\\\n      `)\n      return false\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint)\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(parsedResult.operationName || '')\n        : parsedResult.operationName === this.info.operationName\n\n    return (\n      hasMatchingUrl.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedRequest: ParsedGraphQLRequest,\n  ) {\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n    const requestInfo = parsedRequest?.operationName\n      ? `${parsedRequest?.operationType} ${parsedRequest?.operationName}`\n      : `anonymous ${parsedRequest?.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s (%c%s%c)'),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { store } from '@mswjs/cookies'\nimport { MockedResponse } from '../../response'\nimport { MockedRequest } from './MockedRequest'\n\nexport function readResponseCookies(\n  request: MockedRequest,\n  response: MockedResponse,\n) {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","import { ClientRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/ClientRequest/index.js'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js'\nimport { FetchInterceptor } from '@mswjs/interceptors/lib/interceptors/fetch/index.js'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { SetupServer } from './glossary'\nimport { SetupServerApi } from './SetupServerApi'\n\n/**\n * Sets up a requests interception in Node.js with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n * @see {@link https://mswjs.io/docs/api/setup-server `setupServer`}\n */\nexport const setupServer = (\n  ...handlers: Array<RequestHandler>\n): SetupServer => {\n  return new SetupServerApi(\n    [ClientRequestInterceptor, XMLHttpRequestInterceptor, FetchInterceptor],\n    ...handlers,\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}